<?xml version="1.0"?>
<!-- This file was automatically generated from C sources - DO NOT EDIT!
To affect the contents of this file, edit the original C definitions,
and/or use gtk-doc annotations.  -->
<repository xmlns="http://www.gtk.org/introspection/core/1.0" xmlns:c="http://www.gtk.org/introspection/c/1.0" xmlns:doc="http://www.gtk.org/introspection/doc/1.0" xmlns:glib="http://www.gtk.org/introspection/glib/1.0" version="1.2">
  <include name="GLib" version="2.0"/>
  <package name="glib-2.0"/>
  <c:include name="glib-unix.h"/>
  <c:include name="glib.h"/>
  <doc:format name="gi-docgen"/>
  <namespace name="GLibUnix" version="2.0" shared-library="libgobject-2.0.so.0,libglib-2.0.so.0" c:identifier-prefixes="GUnix,G" c:symbol-prefixes="glib,g_unix,g">
    <callback name="FDSourceFunc" c:type="GUnixFDSourceFunc">
      <doc xml:space="preserve">The type of functions to be called when a UNIX fd watch source
triggers.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%FALSE if the source should be removed</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">the fd that triggered the event</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">the IO conditions reported on @fd</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1" closure="2">
          <doc xml:space="preserve">user data passed to g_unix_fd_add()</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </callback>
    <record name="Pipe" c:type="GUnixPipe" version="2.80">
      <doc xml:space="preserve">A Unix pipe. The advantage of this type over `int[2]` is that it can
be closed automatically when it goes out of scope, using `g_auto(GUnixPipe)`,
on compilers that support that feature.</doc>
      <field name="fds" writable="1">
        <doc xml:space="preserve">A pair of file descriptors, each negative if closed or not yet opened.
 The file descriptor with index %G_UNIX_PIPE_END_READ is readable.
 The file descriptor with index %G_UNIX_PIPE_END_WRITE is writable.</doc>
        <array zero-terminated="0" fixed-size="2">
          <type name="gint" c:type="int"/>
        </array>
      </field>
      <method-inline name="clear" c:identifier="g_unix_pipe_clear" version="2.80" introspectable="0">
        <doc xml:space="preserve">Close both ends of the pipe, unless they have already been closed or
stolen. Any errors are ignored: use g_unix_pipe_close() or g_clear_fd()
if error-handling is required.

This function is async-signal safe if @error is %NULL and each member
of @fds are either negative or a valid open file descriptor.
As a result, it is safe to call this function or use `g_auto(GUnixPipe)`
(on compilers that support it) in a signal handler or a
#GSpawnChildSetupFunc, as long as those conditions are ensured to be true.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.

This function preserves the value of `errno`.</doc>
        <return-value transfer-ownership="none">
          <type name="none" c:type="void"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">a #GUnixPipe</doc>
            <type name="Pipe" c:type="GUnixPipe*"/>
          </instance-parameter>
        </parameters>
      </method-inline>
      <method-inline name="close" c:identifier="g_unix_pipe_close" version="2.80" introspectable="0" throws="1">
        <doc xml:space="preserve">Close one of the ends of the pipe and set the relevant member of @fds
to `-1` before returning, equivalent to g_clear_fd().

Like g_close(), if closing the file descriptor fails, the error is
stored in both %errno and @error. If this function succeeds,
%errno is undefined.

This function is async-signal safe if @error is %NULL and the relevant
member of @fds is either negative or a valid open file descriptor.
This makes it safe to call from a signal handler or a #GSpawnChildSetupFunc
under those conditions.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.

To close both file descriptors and ignore any errors, use
g_unix_pipe_clear() instead.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A pair of file descriptors</doc>
            <type name="Pipe" c:type="GUnixPipe*"/>
          </instance-parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">One of the ends of the pipe</doc>
            <type name="PipeEnd" c:type="GUnixPipeEnd"/>
          </parameter>
        </parameters>
      </method-inline>
      <method-inline name="get" c:identifier="g_unix_pipe_get" version="2.80" introspectable="0">
        <doc xml:space="preserve">Return one of the ends of the pipe. It remains owned by @self.

This function is async-signal safe (see [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7))), making it safe to call from a
signal handler or a #GSpawnChildSetupFunc.

This function preserves the value of `errno`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a non-negative file descriptor owned by @self, which must not
 be closed by the caller, or a negative number if the corresponding
 end of the pipe was already closed or stolen</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A pair of file descriptors</doc>
            <type name="Pipe" c:type="GUnixPipe*"/>
          </instance-parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">One of the ends of the pipe</doc>
            <type name="PipeEnd" c:type="GUnixPipeEnd"/>
          </parameter>
        </parameters>
      </method-inline>
      <method-inline name="open" c:identifier="g_unix_pipe_open" version="2.80" introspectable="0" throws="1">
        <doc xml:space="preserve">Open a pipe. This is the same as g_unix_open_pipe(), but uses the
#GUnixPipe data structure.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">%TRUE on success</doc>
          <type name="gboolean" c:type="gboolean"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A pair of file descriptors</doc>
            <type name="Pipe" c:type="GUnixPipe*"/>
          </instance-parameter>
          <parameter name="flags" transfer-ownership="none">
            <doc xml:space="preserve">Flags to pass to g_unix_open_pipe(), typically `O_CLOEXEC`</doc>
            <type name="gint" c:type="int"/>
          </parameter>
        </parameters>
      </method-inline>
      <method-inline name="steal" c:identifier="g_unix_pipe_steal" version="2.80" introspectable="0">
        <doc xml:space="preserve">Return one of the ends of the pipe. It becomes owned by the caller,
and the file descriptor in the data structure is set to `-1`,
similar to g_steal_fd().

This function is async-signal safe (see [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7))), making it safe to call from a
signal handler or a #GSpawnChildSetupFunc.

This function preserves the value of `errno`.</doc>
        <return-value transfer-ownership="none">
          <doc xml:space="preserve">a non-negative file descriptor, which becomes owned by the
 caller and must be closed by the caller if required, or a negative
 number if the corresponding end of the pipe was already closed or stolen</doc>
          <type name="gint" c:type="int"/>
        </return-value>
        <parameters>
          <instance-parameter name="self" transfer-ownership="none">
            <doc xml:space="preserve">A pair of file descriptors</doc>
            <type name="Pipe" c:type="GUnixPipe*"/>
          </instance-parameter>
          <parameter name="end" transfer-ownership="none">
            <doc xml:space="preserve">One of the ends of the pipe</doc>
            <type name="PipeEnd" c:type="GUnixPipeEnd"/>
          </parameter>
        </parameters>
      </method-inline>
    </record>
    <enumeration name="PipeEnd" version="2.80" c:type="GUnixPipeEnd">
      <doc xml:space="preserve">Mnemonic constants for the ends of a Unix pipe.</doc>
      <member name="read" value="0" c:identifier="G_UNIX_PIPE_END_READ">
        <doc xml:space="preserve">The readable file descriptor 0</doc>
      </member>
      <member name="write" value="1" c:identifier="G_UNIX_PIPE_END_WRITE">
        <doc xml:space="preserve">The writable file descriptor 1</doc>
      </member>
    </enumeration>
    <function name="closefrom" c:identifier="g_closefrom" version="2.80">
      <doc xml:space="preserve">Close every file descriptor equal to or greater than @lowfd.

Typically @lowfd will be 3, to leave standard input, standard output
and standard error open.

This is the same as Linux `close_range (lowfd, ~0U, 0)`,
but portable to other OSs and to older versions of Linux.
Equivalently, it is the same as BSD `closefrom (lowfd)`, but portable,
and async-signal-safe on all OSs.

This function is async-signal safe, making it safe to call from a
signal handler or a [callback@GLib.SpawnChildSetupFunc], as long as @lowfd is
non-negative.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 with errno set on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="lowfd" transfer-ownership="none">
          <doc xml:space="preserve">Minimum fd to close, which must be non-negative</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="error_quark" c:identifier="g_unix_error_quark">
      <return-value transfer-ownership="none">
        <type name="GLib.Quark" c:type="GQuark"/>
      </return-value>
    </function>
    <function name="fd_add" c:identifier="g_unix_fd_add" version="2.36" introspectable="0">
      <doc xml:space="preserve">Sets a function to be called when the IO condition, as specified by
@condition becomes true for @fd.

@function will be called when the specified IO condition becomes
%TRUE.  The function is expected to clear whatever event caused the
IO condition to become true and return %TRUE in order to be notified
when it happens again.  If @function returns %FALSE then the watch
will be cancelled.

The return value of this function can be passed to g_source_remove()
to cancel the watch at any time that it exists.

The source will never close the fd -- you must do it yourself.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">IO conditions to watch for on @fd</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" closure="3">
          <doc xml:space="preserve">a #GUnixFDSourceFunc</doc>
          <type name="FDSourceFunc" c:type="GUnixFDSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="fd_add_full" c:identifier="g_unix_fd_add_full" version="2.36">
      <doc xml:space="preserve">Sets a function to be called when the IO condition, as specified by
@condition becomes true for @fd.

This is the same as g_unix_fd_add(), except that it allows you to
specify a non-default priority and a provide a #GDestroyNotify for
@user_data.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">the ID (greater than 0) of the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the source</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">IO conditions to watch for on @fd</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </parameter>
        <parameter name="function" transfer-ownership="none" scope="notified" closure="4" destroy="5">
          <doc xml:space="preserve">a #GUnixFDSourceFunc</doc>
          <type name="FDSourceFunc" c:type="GUnixFDSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">data to pass to @function</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">function to call when the idle is removed, or %NULL</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="fd_query_path" c:identifier="g_unix_fd_query_path" version="2.88" throws="1">
      <doc xml:space="preserve">Queries the file path for the given FD opened by the current process.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">The file path, or `NULL` on error</doc>
        <type name="utf8" c:type="char*"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">The file descriptor to query.</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="fd_source_new" c:identifier="g_unix_fd_source_new" version="2.36">
      <doc xml:space="preserve">Creates a #GSource to watch for a particular I/O condition on a file
descriptor.

The source will never close the @fd &#x2014; you must do it yourself.

Any callback attached to the returned #GSource must have type
#GUnixFDSourceFunc.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">the newly created #GSource</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">a file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="condition" transfer-ownership="none">
          <doc xml:space="preserve">I/O conditions to watch for on @fd</doc>
          <type name="GLib.IOCondition" c:type="GIOCondition"/>
        </parameter>
      </parameters>
    </function>
    <function name="fdwalk_set_cloexec" c:identifier="g_fdwalk_set_cloexec" version="2.80">
      <doc xml:space="preserve">Mark every file descriptor equal to or greater than @lowfd to be closed
at the next `execve()` or similar, as if via the `FD_CLOEXEC` flag.

Typically @lowfd will be 3, to leave standard input, standard output
and standard error open after exec.

This is the same as Linux `close_range (lowfd, ~0U, CLOSE_RANGE_CLOEXEC)`,
but portable to other OSs and to older versions of Linux.

This function is async-signal safe, making it safe to call from a
signal handler or a [callback@GLib.SpawnChildSetupFunc], as long as @lowfd is
non-negative.
See [`signal(7)`](man:signal(7)) and
[`signal-safety(7)`](man:signal-safety(7)) for more details.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">0 on success, -1 with errno set on error</doc>
        <type name="gint" c:type="int"/>
      </return-value>
      <parameters>
        <parameter name="lowfd" transfer-ownership="none">
          <doc xml:space="preserve">Minimum fd to act on, which must be non-negative</doc>
          <type name="gint" c:type="int"/>
        </parameter>
      </parameters>
    </function>
    <function name="get_passwd_entry" c:identifier="g_unix_get_passwd_entry" version="2.64" throws="1">
      <doc xml:space="preserve">Get the `passwd` file entry for the given @user_name using `getpwnam_r()`.
This can fail if the given @user_name doesn&#x2019;t exist.

The returned `struct passwd` has been allocated using g_malloc() and should
be freed using g_free(). The strings referenced by the returned struct are
included in the same allocation, so are valid until the `struct passwd` is
freed.

This function is safe to call from multiple threads concurrently.

You will need to include `pwd.h` to get the definition of `struct passwd`.</doc>
      <return-value transfer-ownership="full" nullable="1">
        <doc xml:space="preserve">passwd entry, or %NULL on error; free the returned
   value with g_free()</doc>
        <type name="gpointer" c:type="passwd*"/>
      </return-value>
      <parameters>
        <parameter name="user_name" transfer-ownership="none">
          <doc xml:space="preserve">the username to get the passwd file entry for</doc>
          <type name="utf8" c:type="const gchar*"/>
        </parameter>
      </parameters>
    </function>
    <function name="open_pipe" c:identifier="g_unix_open_pipe" version="2.30" throws="1">
      <doc xml:space="preserve">Similar to the UNIX pipe() call, but on modern systems like Linux
uses the pipe2() system call, which atomically creates a pipe with
the configured flags.

As of GLib 2.78, the supported flags are `O_CLOEXEC`/`FD_CLOEXEC` (see below)
and `O_NONBLOCK`. Prior to GLib 2.78, only `FD_CLOEXEC` was supported &#x2014; if
you wanted to configure `O_NONBLOCK` then that had to be done separately with
`fcntl()`.

Since GLib 2.80, the constants %G_UNIX_PIPE_END_READ and
%G_UNIX_PIPE_END_WRITE can be used as mnemonic indexes in @fds.

It is a programmer error to call this function with unsupported flags, and a
critical warning will be raised.

As of GLib 2.78, it is preferred to pass `O_CLOEXEC` in, rather than
`FD_CLOEXEC`, as that matches the underlying `pipe()` API more closely. Prior
to 2.78, only `FD_CLOEXEC` was supported. Support for `FD_CLOEXEC` may be
deprecated and removed in future.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE on success, %FALSE if not (and errno will be set).</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fds" transfer-ownership="none">
          <doc xml:space="preserve">Array of two integers</doc>
          <array zero-terminated="0" c:type="gint*" fixed-size="2">
            <type name="gint" c:type="gint"/>
          </array>
        </parameter>
        <parameter name="flags" transfer-ownership="none">
          <doc xml:space="preserve">Bitfield of file descriptor flags, as for fcntl()</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
    <function name="set_fd_nonblocking" c:identifier="g_unix_set_fd_nonblocking" version="2.30" throws="1">
      <doc xml:space="preserve">Control the non-blocking state of the given file descriptor,
according to @nonblock. On most systems this uses %O_NONBLOCK, but
on some older ones may use %O_NDELAY.</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">%TRUE if successful</doc>
        <type name="gboolean" c:type="gboolean"/>
      </return-value>
      <parameters>
        <parameter name="fd" transfer-ownership="none">
          <doc xml:space="preserve">A file descriptor</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="nonblock" transfer-ownership="none">
          <doc xml:space="preserve">If %TRUE, set the descriptor to be non-blocking</doc>
          <type name="gboolean" c:type="gboolean"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_add" c:identifier="g_unix_signal_add" shadowed-by="signal_add_full" version="2.30" introspectable="0">
      <doc xml:space="preserve">A convenience function for g_unix_signal_source_new(), which
attaches to the default #GMainContext.  You can remove the watch
using g_source_remove().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An ID (greater than 0) for the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="signum" transfer-ownership="none">
          <doc xml:space="preserve">Signal number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="handler" transfer-ownership="none" closure="2">
          <doc xml:space="preserve">Callback</doc>
          <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Data for @handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_add_full" c:identifier="g_unix_signal_add_full" shadows="signal_add" version="2.30">
      <doc xml:space="preserve">A convenience function for g_unix_signal_source_new(), which
attaches to the default #GMainContext.  You can remove the watch
using g_source_remove().</doc>
      <return-value transfer-ownership="none">
        <doc xml:space="preserve">An ID (greater than 0) for the event source</doc>
        <type name="guint" c:type="guint"/>
      </return-value>
      <parameters>
        <parameter name="priority" transfer-ownership="none">
          <doc xml:space="preserve">the priority of the signal source. Typically this will be in
           the range between %G_PRIORITY_DEFAULT and %G_PRIORITY_HIGH.</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="signum" transfer-ownership="none">
          <doc xml:space="preserve">Signal number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
        <parameter name="handler" transfer-ownership="none" scope="notified" closure="3" destroy="4">
          <doc xml:space="preserve">Callback</doc>
          <type name="GLib.SourceFunc" c:type="GSourceFunc"/>
        </parameter>
        <parameter name="user_data" transfer-ownership="none" nullable="1" allow-none="1">
          <doc xml:space="preserve">Data for @handler</doc>
          <type name="gpointer" c:type="gpointer"/>
        </parameter>
        <parameter name="notify" transfer-ownership="none" scope="async">
          <doc xml:space="preserve">#GDestroyNotify for @handler</doc>
          <type name="GLib.DestroyNotify" c:type="GDestroyNotify"/>
        </parameter>
      </parameters>
    </function>
    <function name="signal_source_new" c:identifier="g_unix_signal_source_new" version="2.30">
      <doc xml:space="preserve">Create a #GSource that will be dispatched upon delivery of the UNIX
signal @signum.  In GLib versions before 2.36, only `SIGHUP`, `SIGINT`,
`SIGTERM` can be monitored.  In GLib 2.36, `SIGUSR1` and `SIGUSR2`
were added. In GLib 2.54, `SIGWINCH` was added.

Note that unlike the UNIX default, all sources which have created a
watch will be dispatched, regardless of which underlying thread
invoked g_unix_signal_source_new().

For example, an effective use of this function is to handle `SIGTERM`
cleanly; flushing any outstanding files, and then calling
g_main_loop_quit().  It is not safe to do any of this from a regular
UNIX signal handler; such a handler may be invoked while malloc() or
another library function is running, causing reentrancy issues if the
handler attempts to use those functions.  None of the GLib/GObject
API is safe against this kind of reentrancy.

The interaction of this source when combined with native UNIX
functions like sigprocmask() is not defined.

The source will not initially be associated with any #GMainContext
and must be added to one with g_source_attach() before it will be
executed.</doc>
      <return-value transfer-ownership="full">
        <doc xml:space="preserve">A newly created #GSource</doc>
        <type name="GLib.Source" c:type="GSource*"/>
      </return-value>
      <parameters>
        <parameter name="signum" transfer-ownership="none">
          <doc xml:space="preserve">A signal number</doc>
          <type name="gint" c:type="gint"/>
        </parameter>
      </parameters>
    </function>
  </namespace>
</repository>
